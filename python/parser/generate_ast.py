"""Util to generate classes for expressions given a textual description of the grammar.

The generator passes a file in which each line follows the following format:

    ClassName arg1 arg1_type arg2 arg2_type ... argn argn_type

Then this will generate a class in the following form:
    @dataclass
    ClassName:
        arg1: arg1_type
        arg2: arg2_type
        .
        .
        .
"""

import argparse
import os


def parse_args():
    """
    Parse command line arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input_file",
        type=str,
        required=True,
        help="Filepath to the grammar used for \
                code generation.",
    )

    parser.add_argument(
        "--output_file",
        type=str,
        help="Path to the generated python file.",
        required=True,
    )

    return parser.parse_args()


def generate_ast(grammar: str):
    """Generates classes for each expression type."""

    output = '"""This file is autogenerated by generate_ast.py\n\
    do not modify manually the content."""\n\n'

    output += "# pylint: disable=C0114,C0115,C0116\n\n"

    output += "from dataclasses import dataclass\n\n"
    output += "from scanner.token import Token\n\n"
    output += 'class ExpressionBase: # pylint: disable=too-few-public-methods\n\
    """Base class for expression classes"""\n\n'

    for expression in grammar.splitlines():
        rule = expression.split()
        name = rule[0]

        output += f"@dataclass\nclass {name}Expr(ExpressionBase):\n"
        output += f'    """Data class for expressions of type {name}"""\n\n'

        for var, var_type in zip(rule[1::2], rule[2::2]):
            output += f"    {var}: {var_type}\n"
        output += "\n"
        output += "    def accept(self, visitor):\n"
        output += f"        return visitor.visit_{name.lower()}_expr(self)\n\n"
        output += "\n\n"
    return output


def main():
    """Main for the expression class generator"""
    args = parse_args()
    if args.input_file:
        if os.path.isfile(args.input_file):
            with open(args.input_file, "r", encoding="utf-8") as file:
                grammar = file.read()
                ast = generate_ast(grammar)
            with open(args.output_file, "w", encoding="utf-8") as output_file:
                output_file.write(ast)
        else:
            raise ValueError(f"Provided file {args.filepath} is not a file.")


if __name__ == "__main__":
    main()
